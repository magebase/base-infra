name: Update ArgoCD Applications on Release

on:
  repository_dispatch:
    types: [trigger-workflow]
  workflow_dispatch:
    inputs:
      repository:
        description: "Repository that created the release"
        required: true
        type: string
      tag:
        description: "Tag to update to"
        required: true
        type: string
      environment:
        description: "Target environment"
        required: true
        type: choice
        options:
          - dev
          - prod
      regions:
        description: "Target regions for the environment (comma-separated)"
        required: false
        type: string

jobs:
  semantic-release:
    name: "Semantic Release"
    runs-on: ubicloud-standard-2-arm
    permissions:
      contents: write
      pull-requests: write
    outputs:
      new_release_published: ${{ steps.semantic.outputs.new_release_published }}
      new_release_version: ${{ steps.semantic.outputs.new_release_version }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Run semantic-release
        id: semantic
        uses: cycjimmy/semantic-release-action@v4
        with:
          branches: main
          dry_run: ${{ github.event_name == 'pull_request' }}
          extra_plugins: |
            @semantic-release/git
            @semantic-release/github
            @semantic-release/changelog
            @semantic-release/exec
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Set outputs for dry run
        if: github.event_name == 'pull_request'
        run: |
          echo "new_release_published=false" >> $GITHUB_OUTPUT
          echo "new_release_version=dry-run" >> $GITHUB_OUTPUT

  update-argocd-app:
    name: "Update ArgoCD Application"
    runs-on: ubicloud-standard-2-arm
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Checkout base-infra repository
        uses: actions/checkout@v4
        with:
          repository: magebase/base-infra
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Check if ArgoCD update is needed
        id: should-update
        run: |
          if [ "${{ steps.repo-info.outputs.repository }}" = "magebase/base-infra" ]; then
            echo "‚ÑπÔ∏è  Skipping ArgoCD update for base-infra release"
            echo "should_update=false" >> $GITHUB_OUTPUT
          else
            echo "should_update=true" >> $GITHUB_OUTPUT
          fi

      - name: Determine repository and application details
        id: repo-info
        run: |
          echo "üîç Debug: Event name is ${{ github.event_name }}"
          echo "üîç Debug: Current repository is ${{ github.repository }}"

          # Get repository name from release, repository_dispatch, or workflow dispatch
          if [ "${{ github.event_name }}" = "release" ]; then
            echo "üîç Debug: Release event detected"
            REPO_NAME="${{ github.repository }}"
            TAG_NAME="${{ github.event.release.tag_name }}"
            ENVIRONMENT="prod"  # Default to prod for releases in base-infra
          elif [ "${{ github.event_name }}" = "repository_dispatch" ]; then
            echo "üîç Debug: Client payload repository: ${{ github.event.client_payload.repository }}"
            REPO_NAME="${{ github.event.client_payload.repository }}"
            TAG_NAME="${{ github.event.client_payload.tag }}"
            ENVIRONMENT="${{ github.event.client_payload.to_environment || 'prod' }}"

            # Validate repository exists in clients.json (for repository_dispatch)
            CLIENT_EXISTS=$(jq -r --arg repo "$REPO_NAME" '.[] | select(.repository == $repo) | .name' "infra/pipeline/base-infrastructure/clients.json")
            if [ -z "$CLIENT_EXISTS" ] && [ "$REPO_NAME" != "magebase/base-infra" ]; then
              echo "‚ùå Repository $REPO_NAME not found in clients.json"
              exit 1
            fi

            echo "üì¶ Repository dispatch detected: $REPO_NAME $TAG_NAME"
          else
            echo "üîç Debug: Workflow dispatch repository input: ${{ github.event.inputs.repository }}"
            REPO_NAME="${{ github.event.inputs.repository }}"
            TAG_NAME="${{ github.event.inputs.tag }}"
            ENVIRONMENT="${{ github.event.inputs.environment }}"

            # Validate repository exists in clients.json (for workflow_dispatch)
            CLIENT_EXISTS=$(jq -r --arg repo "$REPO_NAME" '.[] | select(.repository == $repo) | .name' "infra/pipeline/base-infrastructure/clients.json")
            if [ -z "$CLIENT_EXISTS" ] && [ "$REPO_NAME" != "magebase/base-infra" ]; then
              echo "‚ùå Repository $REPO_NAME not found in clients.json"
              exit 1
            fi
          fi

          # Set default regions based on environment
          case "$ENVIRONMENT" in
            "dev")
              DEFAULT_REGIONS="fsn1"
              ;;
            # "qa")  # Commented out - QA deployments disabled
            #   DEFAULT_REGIONS="fsn1,nbg1"
            #   ;;
            # "uat") # Commented out - UAT deployments disabled
            #   DEFAULT_REGIONS="fsn1,nbg1,hel1"
            #   ;;
            "prod")
              DEFAULT_REGIONS="fsn1"
              ;;
            *)
              DEFAULT_REGIONS="fsn1"
              ;;
          esac

          # Use provided regions or defaults
          if [ "${{ github.event_name }}" = "repository_dispatch" ] && [ -n "${{ github.event.client_payload.regions }}" ]; then
            REGIONS="${{ github.event.client_payload.regions }}"
          elif [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ github.event.inputs.regions }}" ]; then
            REGIONS="${{ github.event.inputs.regions }}"
          else
            REGIONS="$DEFAULT_REGIONS"
          fi

          echo "Repository: $REPO_NAME"
          echo "Tag: $TAG_NAME"
          echo "Environment: $ENVIRONMENT"
          echo "Regions: $REGIONS"

          # Validate tag format (should be semantic version)
          if [[ ! "$TAG_NAME" =~ ^v[0-9]+\.[0-9]+\.[0-9]+ ]]; then
            echo "‚ö†Ô∏è  Warning: Tag $TAG_NAME does not follow semantic versioning (v1.2.3)"
          fi

          # Convert comma-separated regions to array
          IFS=',' read -ra REGION_ARRAY <<< "$REGIONS"

          # Define clients.json path for validation
          CLIENTS_FILE="infra/pipeline/base-infrastructure/clients.json"

          # Validate repository exists in clients.json
          CLIENT_EXISTS=$(jq -r --arg repo "$REPO_NAME" '.[] | select(.repository == $repo) | .name' "$CLIENTS_FILE")

          if [ -z "$CLIENT_EXISTS" ]; then
            echo "‚ùå Repository $REPO_NAME not found in clients.json"
            exit 1
          fi

          echo "‚úÖ Repository $REPO_NAME found in clients.json (client: $CLIENT_EXISTS)"

          echo "repository=$REPO_NAME" >> $GITHUB_OUTPUT
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "regions=$REGIONS" >> $GITHUB_OUTPUT

      - name: Update targetRevision in clients.json
        if: steps.should-update.outputs.should_update == 'true'
        run: |
          echo "üîç Debug: About to update clients.json with:"
          echo "  Repository: ${{ steps.repo-info.outputs.repository }}"
          echo "  Tag: ${{ steps.repo-info.outputs.tag_name }}"
          echo "  Environment: ${{ steps.repo-info.outputs.environment }}"

          CLIENTS_FILE="infra/pipeline/base-infrastructure/clients.json"

          # Get client name from repository using jq
          CLIENT_NAME=$(jq -r --arg repo "${{ steps.repo-info.outputs.repository }}" '.[] | select(.repository == $repo) | .name' "$CLIENTS_FILE")

          if [ -z "$CLIENT_NAME" ]; then
            echo "‚ùå Could not find client name for repository ${{ steps.repo-info.outputs.repository }}"
            exit 1
          fi

          echo "üìù Updating targetRevision for $CLIENT_NAME in ${{ steps.repo-info.outputs.environment }} environment to ${{ steps.repo-info.outputs.tag_name }}"

          # Update the targetRevision in clients.json using jq
          jq --arg client "$CLIENT_NAME" \
             --arg env "${{ steps.repo-info.outputs.environment }}" \
             --arg tag "${{ steps.repo-info.outputs.tag_name }}" \
             'map(if .name == $client then .targetRevision[$env] = $tag else . end)' \
             "$CLIENTS_FILE" > "${CLIENTS_FILE}.tmp" && mv "${CLIENTS_FILE}.tmp" "$CLIENTS_FILE"

          echo "‚úÖ Updated clients.json with new targetRevision"

      - name: Verify clients.json update
        if: steps.should-update.outputs.should_update == 'true'
        run: |
          echo "üîç Verifying clients.json was updated correctly..."

          CLIENTS_FILE="infra/pipeline/base-infrastructure/clients.json"

          # Get client name from repository using jq
          CLIENT_NAME=$(jq -r --arg repo "${{ steps.repo-info.outputs.repository }}" '.[] | select(.repository == $repo) | .name' "$CLIENTS_FILE")

          if [ -z "$CLIENT_NAME" ]; then
            echo "‚ùå Could not find client name for repository ${{ steps.repo-info.outputs.repository }}"
            exit 1
          fi

          # Verify the targetRevision was updated
          UPDATED_TAG=$(jq -r \
            --arg client "$CLIENT_NAME" \
            --arg env "${{ steps.repo-info.outputs.environment }}" \
            '.[] | select(.name == $client) | .targetRevision[$env]' \
            "$CLIENTS_FILE")

          if [ "$UPDATED_TAG" = "${{ steps.repo-info.outputs.tag_name }}" ]; then
            echo "‚úÖ Verification successful: $CLIENT_NAME targetRevision for ${{ steps.repo-info.outputs.environment }} is now $UPDATED_TAG"
          else
            echo "‚ùå Verification failed: Expected ${{ steps.repo-info.outputs.tag_name }}, but found $UPDATED_TAG"
            exit 1
          fi

      - name: Commit changes directly to main
        if: steps.should-update.outputs.should_update == 'true'
        run: |
          echo "üîÑ Committing changes directly to main branch..."

          # Configure git
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          # Add the updated clients.json file
          git add infra/pipeline/base-infrastructure/clients.json

          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "‚ÑπÔ∏è  No changes to commit - clients.json is already up to date"
          else
            # Create commit message
            COMMIT_MESSAGE=$(printf "üöÄ [%s] Update %s targetRevision to %s\n\nThis change updates clients.json to set the targetRevision for %s\nto use the new release %s for %s environment.\n\nTriggered by release in %s" \
              "${{ steps.repo-info.outputs.environment }}" \
              "${{ steps.repo-info.outputs.repository }}" \
              "${{ steps.repo-info.outputs.tag_name }}" \
              "${{ steps.repo-info.outputs.repository }}" \
              "${{ steps.repo-info.outputs.tag_name }}" \
              "${{ steps.repo-info.outputs.environment }}" \
              "${{ steps.repo-info.outputs.repository }}")

            # Commit the changes
            git commit -m "$COMMIT_MESSAGE"

            # Push to main branch
            git push origin main

            echo "‚úÖ Successfully committed and pushed changes to main"
            echo "üìù Commit message: $COMMIT_MESSAGE"
          fi

      - name: Comment on release
        if: github.event_name == 'release'
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `ü§ñ **TargetRevision Update Completed**\n\nI've successfully updated clients.json with this release.\n\n**Changes:**\n- Updated targetRevision.${{ steps.repo-info.outputs.environment }} to \`${{ steps.repo-info.outputs.tag_name }}\` in clients.json\n\nArgoCD applications will now use the updated targetRevision via environment variables.`
            })

      - name: Comment on repository dispatch
        if: github.event_name == 'repository_dispatch' && steps.should-update.outputs.should_update == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            // For repository_dispatch, we can't comment on the original release
            // This would need to be handled differently if commenting is required
            console.log('Repository dispatch detected - skipping release comment')

      - name: Output summary
        if: steps.should-update.outputs.should_update == 'true'
        run: |
          echo "üéâ **Update Summary**"
          echo "- Repository: ${{ steps.repo-info.outputs.repository }}"
          echo "- File Updated: infra/pipeline/base-infrastructure/clients.json"
          echo "- Environment: ${{ steps.repo-info.outputs.environment }}"
          echo "- New Tag: ${{ steps.repo-info.outputs.tag_name }}"
          echo "- Status: ‚úÖ Committed directly to main branch"
          echo ""
          echo "Next steps:"
          echo "1. ArgoCD applications will use the updated targetRevision from clients.json via environment variables"
