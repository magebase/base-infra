name: Promote Application Release

on:
  repository_dispatch:
    types:
      - release-published
  workflow_dispatch:
    inputs:
      repository:
        description: "Repository to promote"
        required: true
        type: choice
        options:
          - magebase/genfix
          - magebase/site
      tag:
        description: "Tag to promote"
        required: true
        type: string
      from_environment:
        description: "Source environment"
        required: true
        type: choice
        options:
          - dev
          # - qa  # Commented out - QA deployments disabled
          # - uat # Commented out - UAT deployments disabled
      to_environment:
        description: "Target environment"
        required: true
        type: choice
        options:
          # - qa  # Commented out - QA deployments disabled
          # - uat # Commented out - UAT deployments disabled
          - prod

jobs:
  semantic-release:
    name: "Semantic Release"
    runs-on: ubicloud-standard-2-arm
    permissions:
      contents: write
      pull-requests: write
    outputs:
      new_release_published: ${{ steps.semantic.outputs.new_release_published }}
      new_release_version: ${{ steps.semantic.outputs.new_release_version }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Run semantic-release
        id: semantic
        uses: cycjimmy/semantic-release-action@v4
        with:
          branches: main
          dry_run: ${{ github.event_name == 'pull_request' }}
          extra_plugins: |
            @semantic-release/git
            @semantic-release/github
            @semantic-release/changelog
            @semantic-release/exec
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Set outputs for dry run
        if: github.event_name == 'pull_request'
        run: |
          echo "new_release_published=false" >> $GITHUB_OUTPUT
          echo "new_release_version=dry-run" >> $GITHUB_OUTPUT

  validate-promotion:
    name: "Validate Promotion"
    runs-on: ubicloud-standard-2-arm
    outputs:
      can_promote: ${{ steps.validate.outputs.can_promote }}
      repository: ${{ steps.validate.outputs.repository }}
      tag: ${{ steps.validate.outputs.tag }}
      from_environment: ${{ steps.validate.outputs.from_environment }}
      to_environment: ${{ steps.validate.outputs.to_environment }}
    steps:
      - name: Validate promotion logic
        id: validate
        run: |
          # Handle different trigger types
          if [ "${{ github.event_name }}" = "release" ]; then
            # Extract repository from release event
            REPO_FULL="${{ github.event.release.html_url }}"
            REPO_NAME=$(echo "$REPO_FULL" | sed 's|https://github.com/||' | sed 's|/releases/tag/.*||')
            TAG="${{ github.event.release.tag_name }}"
            FROM_ENV="dev"  # Default for releases
            TO_ENV="prod"   # Default for releases
            echo "üì¶ Release detected: $REPO_NAME $TAG"
          elif [ "${{ github.event_name }}" = "repository_dispatch" ]; then
            # Handle repository dispatch from genfix or site repos
            REPO_NAME="${{ github.event.client_payload.repository }}"
            TAG="${{ github.event.client_payload.tag }}"
            FROM_ENV="${{ github.event.client_payload.from_environment || 'dev' }}"
            TO_ENV="${{ github.event.client_payload.to_environment || 'prod' }}"

            # Validate that only allowed repositories can trigger this workflow
            ALLOWED_REPOS=("magebase/genfix" "magebase/site")
            if [[ "$REPO_NAME" != "magebase/genfix" && "$REPO_NAME" != "magebase/site" ]]; then
              echo "‚ùå Unauthorized repository: $REPO_NAME"
              echo "can_promote=false" >> $GITHUB_OUTPUT
              exit 1
            fi

            echo "üì¶ Repository dispatch detected: $REPO_NAME $TAG"
          else
            # Workflow dispatch
            REPO_NAME="${{ github.event.inputs.repository }}"
            TAG="${{ github.event.inputs.tag }}"
            FROM_ENV="${{ github.event.inputs.from_environment }}"
            TO_ENV="${{ github.event.inputs.to_environment }}"
          fi

          echo "repository=$REPO_NAME" >> $GITHUB_OUTPUT
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "from_environment=$FROM_ENV" >> $GITHUB_OUTPUT
          echo "to_environment=$TO_ENV" >> $GITHUB_OUTPUT

          # Define regions for each environment
          case "$FROM_ENV" in
            "dev")
              FROM_REGIONS="fsn1"
              ;;
            # "qa")  # Commented out - QA deployments disabled
            #   FROM_REGIONS="fsn1,nbg1"
            #   ;;
            # "uat") # Commented out - UAT deployments disabled
            #   FROM_REGIONS="fsn1,nbg1,hel1"
            #   ;;
          esac

          case "$TO_ENV" in
            # "qa")  # Commented out - QA deployments disabled
            #   TO_REGIONS="fsn1,nbg1"
            #   ;;
            # "uat") # Commented out - UAT deployments disabled
            #   TO_REGIONS="fsn1,nbg1,hel1"
            #   ;;
            "prod")
              TO_REGIONS="fsn1"
              ;;
          esac

          echo "‚úÖ Promoting from $FROM_ENV to $TO_ENV"
          echo "can_promote=true" >> $GITHUB_OUTPUT

  performance-test:
    name: "Performance Testing"
    runs-on: ubicloud-standard-2-arm
    needs: validate-promotion
    if: needs.validate-promotion.outputs.can_promote == 'true'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Get application URL
        id: get-url
        run: |
          # Get the application URL from environment or repository output
          # This can be customized based on your repository's output format
          if [ -n "${{ secrets.APP_URL }}" ]; then
            APP_URL="${{ secrets.APP_URL }}"
          elif [ -n "${{ vars.APP_URL }}" ]; then
            APP_URL="${{ vars.APP_URL }}"
          else
            # Fallback to environment-based URL construction
            case "${{ needs.validate-promotion.outputs.to_environment }}" in
              "dev")
                APP_URL="https://dev.magebase.dev"
                ;;
              "qa")
                APP_URL="https://qa.magebase.dev"
                ;;
              "prod")
                APP_URL="https://magebase.dev"
                ;;
              *)
                APP_URL="https://magebase.dev"
                ;;
            esac
          fi

          echo "Testing URL: $APP_URL"
          echo "app_url=$APP_URL" >> $GITHUB_OUTPUT

      - name: Run Lighthouse Performance Test
        uses: treosh/lighthouse-ci-action@v10
        with:
          urls: ${{ steps.get-url.outputs.app_url }}
          configPath: .lighthouserc.json
          uploadArtifacts: true
          temporaryPublicStorage: true

      - name: Performance Test Results
        if: always()
        run: |
          echo "üéØ **Performance Test Results**"
          echo "- Application: ${{ needs.validate-promotion.outputs.repository }}"
          echo "- Environment: ${{ needs.validate-promotion.outputs.to_environment }}"
          echo "- Test URL: ${{ steps.get-url.outputs.app_url }}"
          echo "- Results uploaded to temporary storage"

  promote-app:
    name: "Promote Application"
    runs-on: ubicloud-standard-2-arm
    needs: [semantic-release, validate-promotion, performance-test]
    if: needs.validate-promotion.outputs.can_promote == 'true' && needs.performance-test.result == 'success'
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Checkout base-infra repository
        uses: actions/checkout@v4
        with:
          repository: magebase/base-infra
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Validate repository exists in clients.json
        id: validate-repo
        run: |
          CLIENTS_FILE="infra/pipeline/base-infrastructure/clients.json"

          # Check if repository exists in clients.json
          CLIENT_EXISTS=$(jq -r --arg repo "${{ needs.validate-promotion.outputs.repository }}" '.[] | select(.repository == $repo) | .name' "$CLIENTS_FILE")

          if [ -z "$CLIENT_EXISTS" ]; then
            echo "‚ùå Repository ${{ needs.validate-promotion.outputs.repository }} not found in clients.json"
            echo "valid=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          echo "‚úÖ Repository ${{ needs.validate-promotion.outputs.repository }} found in clients.json (client: $CLIENT_EXISTS)"
          echo "client_name=$CLIENT_EXISTS" >> $GITHUB_OUTPUT
          echo "valid=true" >> $GITHUB_OUTPUT

      - name: Update targetRevision in clients.json
        if: steps.validate-repo.outputs.valid == 'true'
        run: |
          CLIENTS_FILE="infra/pipeline/base-infrastructure/clients.json"

          echo "üìù Updating targetRevision for ${{ steps.validate-repo.outputs.client_name }} in ${{ needs.validate-promotion.outputs.to_environment }} environment to ${{ needs.validate-promotion.outputs.tag }}"

          # Update the targetRevision in clients.json using jq
          jq --arg client "${{ steps.validate-repo.outputs.client_name }}" \
             --arg env "${{ needs.validate-promotion.outputs.to_environment }}" \
             --arg tag "${{ needs.validate-promotion.outputs.tag }}" \
             'map(if .name == $client then .targetRevision[$env] = $tag else . end)' \
             "$CLIENTS_FILE" > "${CLIENTS_FILE}.tmp" && mv "${CLIENTS_FILE}.tmp" "$CLIENTS_FILE"

          echo "‚úÖ Updated clients.json with new targetRevision"

      - name: Verify clients.json update
        if: steps.validate-repo.outputs.valid == 'true'
        run: |
          echo "üîç Verifying clients.json was updated correctly..."

          CLIENTS_FILE="infra/pipeline/base-infrastructure/clients.json"

          # Verify the targetRevision was updated
          UPDATED_TAG=$(jq -r --arg client "${{ steps.validate-repo.outputs.client_name }}" --arg env "${{ needs.validate-promotion.outputs.to_environment }}"
            '.[] | select(.name == $client) | .targetRevision[$env]' "$CLIENTS_FILE")

          if [ "$UPDATED_TAG" = "${{ needs.validate-promotion.outputs.tag }}" ]; then
            echo "‚úÖ Verification successful: ${{ steps.validate-repo.outputs.client_name }} targetRevision for ${{ needs.validate-promotion.outputs.to_environment }} is now $UPDATED_TAG"
          else
            echo "‚ùå Verification failed: Expected ${{ needs.validate-promotion.outputs.tag }}, but found $UPDATED_TAG"
            exit 1
          fi

      - name: Create promotion pull request
        id: create-pr
        uses: peter-evans/create-pull-request@v5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: |
            üöÄ Promote ${{ needs.validate-promotion.outputs.repository }} ${{ needs.validate-promotion.outputs.tag }} from ${{ needs.validate-promotion.outputs.from_environment }} to ${{ needs.validate-promotion.outputs.to_environment }}

            This change updates clients.json to set the targetRevision for ${{ needs.validate-promotion.outputs.repository }}
            to use the new release ${{ needs.validate-promotion.outputs.tag }} for ${{ needs.validate-promotion.outputs.to_environment }} environment.
          title: "üöÄ Promote ${{ needs.validate-promotion.outputs.repository }} ${{ needs.validate-promotion.outputs.tag }} from ${{ needs.validate-promotion.outputs.from_environment }} to ${{ needs.validate-promotion.outputs.to_environment }}"
          body: |
            ## üöÄ Application Promotion

            Promoting **${{ needs.validate-promotion.outputs.repository }}** from **${{ needs.validate-promotion.outputs.from_environment }}** to **${{ needs.validate-promotion.outputs.to_environment }}**.

            ### Details
            - **Application:** ${{ needs.validate-promotion.outputs.repository }}
            - **Version:** ${{ needs.validate-promotion.outputs.tag }}
            - **From:** ${{ needs.validate-promotion.outputs.from_environment }}
            - **To:** ${{ needs.validate-promotion.outputs.to_environment }}

            ### Changes
            - Updated `targetRevision.${{ needs.validate-promotion.outputs.to_environment }}` to `${{ needs.validate-promotion.outputs.tag }}` in `clients.json`
            - File: `infra/pipeline/base-infrastructure/clients.json`

            ### Validation Checklist
            - [ ] Application successfully tested in ${{ needs.validate-promotion.outputs.from_environment }}
            - [ ] All automated tests passed
            - [ ] Manual testing completed
            - [ ] Stakeholders approved promotion

            ### Next Steps
            1. Review the changes
            2. Ensure application is stable in ${{ needs.validate-promotion.outputs.from_environment }}
            3. Merge this PR to deploy to ${{ needs.validate-promotion.outputs.to_environment }}
            4. ArgoCD applications will use the updated targetRevision via environment variables
          branch: promote-${{ needs.validate-promotion.outputs.repository }}-${{ needs.validate-promotion.outputs.tag }}-${{ needs.validate-promotion.outputs.from_environment }}-to-${{ needs.validate-promotion.outputs.to_environment }}
          delete-branch: true
          labels: |
            promotion
            ${{ needs.validate-promotion.outputs.repository }}
            ${{ needs.validate-promotion.outputs.to_environment }}

      - name: Output promotion summary
        run: |
          echo "üéâ **Promotion Summary**"
          echo "- Repository: ${{ needs.validate-promotion.outputs.repository }}"
          echo "- Version: ${{ needs.validate-promotion.outputs.tag }}"
          echo "- From: ${{ needs.validate-promotion.outputs.from_environment }}"
          echo "- To: ${{ needs.validate-promotion.outputs.to_environment }}"
          echo "- File Updated: infra/pipeline/base-infrastructure/clients.json"
          echo "- PR Created: ${{ steps.create-pr.outputs.pull-request-url }}"
          echo ""
          echo "Next steps:"
          echo "1. Review and merge the PR"
          echo "2. ArgoCD applications will use the updated targetRevision via environment variables"
